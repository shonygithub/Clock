/* починаючи з 13 версіі збереження усіх налаштувань перенесено на EEPROM інтегрованого у модуль часу DS3231
 * що дає коректну можливість встановити ОТА (перепрошивка по WI FI) 
 * починаючи з 21 версіі добавлено будильник, void setup ,,розрослась,, тому перенесена на слідуючу вкладку
 * починаючи з 31 версіі добавлено реакцію на сенсор руху, щоб після спрацювання будильника зупинити 
 * відтворення треку ,або переходу у підсвічування ,,нічника,, коли годинник перебуває у нічному режимі
 * починаючи з 33 версіі добавлено спробу записати дату і текст привітання
 * починаючи з 39 версіі відкореговано запис дати і тексту привітання
 * починаючи з 42 версіі текст привітання вже побіг по дисплею
 * починаючи з 43 версіі оптимізовано код в фунції setup,результат - звільнилось 804 байт ROM.
 * починаючи з 47 версіі у веб інтерфейсі створено 10 комірок для запису дати і тексту привітання. 
 * починаючи з 49 версіі обрізано до 8 комірок для запису дати і тексту привітання.(Не справлявся...)
 * починаючи з 57 версіі виправлений алгоритм переходів на літній або зимовий час 
 * починаючи з 58 версіі розділові точки у вигляді ,,бігуий вогонь,,
 * починаючи з 59 версіі виправлений алгоритм ,,точки доступа,,
 * починаючи з 62 версіі роутер вже бачить ім'я пристрою ,,хостнейм,,
 * починаючи з 63 версіі продовжений термін світіння нічника внаслідок реагування сенсора руху 
 * починаючи з 64 версіі відтворюється голосове привітання внаслідок реагування сенсора руху один раз на добу з 7 години до 23
 * починаючи з 65 версіі значення температури  вже отримуєм від сенсора ds18b20
 * починаючи з 69 версіі подвійна перевірка часу з NTP сервера
 * починаючи з 70 версіі усунено проблему з І2С
 * починаючи з 71 версіі надіюсь повність'ю.усунено проблему з І2С
 * починаючи з 72 версіі деякі змінні отримують потрібні значення відразу при ініціалізації
 */ 
#include "fonts.h"
#include "timerMinim.h"
timerMinim scrollTimer(30);
#include <ESP8266WiFi.h>
#include <WiFiClient.h>
#include <ESP8266WebServer.h>
#include <ESP8266mDNS.h>
MDNSResponder mdns;
#include <DFPlayer_Mini_Mp3.h>
#include <FastLED.h>
#include <WiFiUdp.h>
#include <DS3232RTC.h>
#include <Wire.h>
#include <RTClib.h> 
#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS 14       //пін підключення DS18B20 (GPIO 14 на WeMos Mini підписаний як D5
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire); 
#define CURRENT_LIMIT 2000    // лимит по току в миллиамперах, автоматически управляет яркостью . 0 - выключить лимит
#define WIDTH 32              // ширина матрицы
#define HEIGHT 8              // высота матрицы
#define COLOR_ORDER GRB       // порядок цветов на ленте. Если цвет отображается некорректно - меняйте. Начать можно с RGB
#define NUM_LEDS WIDTH * HEIGHT 
#define EEPROM_I2C_ADDRESS 0x57
#define DS3231_I2C_ADDRESS 0x68
#define LED_TYPE WS2812B
#define ANALOG_PIN 0          // на пін А0 плати ESP8266 підключайте фотореистор від 3.3 вольт, і опір 20 кОм від GND 
#define NEW_PIXEL_PIN 2       // D4 (GPIO 2)номер піну від плати ESP через резистор 300...500 Ом до середнього контакту WS2812B
#define MOTION_SENSOR_PIN 16  // через резистор 300...500 Ом до сенсора SR602 (пір датчик),(GPIO 16 на WeMos Mini підписания як D0)
RTC_DS3231 rtc;
String runningText = "Привіт";     // створюємо строку у яку запиcуватиметься бігучий текст
const char*ntpServerName = "time.nist.gov";   // якщо для Росії то можна поміняти на "ntp.time.in.ru"
//const char*APssid = "KITCHEN_clock";           // і'мя створеної на ESP8266 сітки WI FI 
//const char*password = "KITCHEN_clock";         // пароль створеної на ESP8266 сітки WI FI
const char*APssid = "SHONY_clock";           // і'мя створеної на ESP8266 сітки WI FI 
const char*password = "SHONY_clock";         // пароль створеної на ESP8266 сітки WI FI
char daysOfTheWeek[7][10] = {"   Sunday", "   Monday", "  Tuesday", "Wednesday", " Thursday", "   Friday", " Saturday"}; 
byte packetBuffer[48];

int8_t GetEEPROM (uint8_t , int8_t , int8_t , int8_t , int8_t ); // об'явили прототип функціі
int8_t brightnessMin =  GetEEPROM (201, 2, 29, 5, 0);        // brightnessMin змінюйте на веб сторінці по свому вподобанню
int8_t brightnessMax =  GetEEPROM (202, 30, 70, 40, 0);      // brightnessMax змінюйте на веб сторінці по свому вподобанню
int8_t temp_corr =  GetEEPROM (203, -10, 10, 4, 100);          // пропишіть не веб сторінці потрібне значення корекції температурного сенсора у модулі DS3231
int8_t timezone =  GetEEPROM (204, -11, 11, 2, 100);           // пропишіть не веб сторінці потрібне значення ,,таймзони,,до переходу на літній час
int8_t setMinute =  GetEEPROM (205, 0, 59, 10, 0);           // задаємо значення при якій хвилині на табло, відбудиться синхронізація часу
int8_t setHour =  GetEEPROM (206, 3, 23, 4, 0);              // задаємо значення при якій годині на табло, відбудиться синхронізація часу
int8_t summerTime =  GetEEPROM (207, 0, 1, 1, 0);                  // для дозволу автоматичного переходу на літній час ставим 1 у інтерфейсі 192.168.4.1/set 
int8_t dst =  GetEEPROM (208, 0, 1, 0, 0);                   // віднімаєм від значення timezone (перехід на літній час)
int8_t volume =  GetEEPROM (209, 1, 30, 10, 0);              // для вибору гучності голосових сповіщень
int8_t nightModeThreshold =  GetEEPROM (210, 1, 30, 3, 0);   // поріг освітленості при якому настає нічний режим 
int8_t nightBrightness =  GetEEPROM (211, 1, 3, 2, 0);       // яскравість матриці у нічному режимі
int8_t minuteAlarmClock =  GetEEPROM (231, 0, 59, 30, 0);    // задаємо значення при якій хвилині на табло, відбудиться активація будильника
int8_t hourAlarmClock =  GetEEPROM (232, 1, 22, 7, 0);       // задаємо значення при якій годині на табло, відбудиться активація будильника
int8_t alarmWorkingDays = (bool) GetEEPROM (233, 0, 1, 1, 0);            // дозволяє активувати режим будильника в будні
int8_t alarmAndWeekend = (bool) GetEEPROM (234, 0, 1, 0, 0);             // дозволяє активувати режим будильника і по вихідних (субота , неділя)
int8_t dawnMode = (bool) GetEEPROM (235, 0, 1, 1, 0);                    // дозволяє активувати режим ,,світанок,,
int8_t aheadAlarm =  GetEEPROM (236, 5, 20, 10, 0);          // на скільки хвилин до спрацювання будильника почнеться ,,світанок,,
int8_t prolongationDawn =  GetEEPROM (237, 1, 10, 3, 0);     // на скільки хвилин після будильника продовжиться ,,світанок,,
int8_t trackNumberAlarm =  GetEEPROM (238, 1, 20, 1, 0);     // вибираємо звук будильника
int8_t trackNumberDawn =  GetEEPROM (239, 1, 10, 1, 0);      // вибираємо звук світанку
int8_t setVolumeAlarm =  GetEEPROM (240, 1, 30, 15, 0);      // задаємо гучність звуку будильника
int8_t setVolumeDawn =  GetEEPROM (241, 1, 30, 10, 0);       // задаємо гучність звуку світанку
int8_t volumeGreeting =  GetEEPROM (242, 0, 30, 20, 0);      // задаємо гучність звуку привітання

byte cantorNightLightTime;  // для нічника
byte lastDay;               // для голосового привітання один раз в сутку
byte counterTrack;          // рахує треки
byte counterText;           // рахує цикли перебігу тексту
byte countText = 1;         // стартове вітання тільки один раз, останній рядок задає кількість циклів перебігу тексту
byte degreeColor;           // для плавної зміни кольорів фону при бігучому тексті
byte globalSpeed = 30;
byte connectCont ;          // для відрахунку терміну одноразової спроби отримання часу з NTP сервера
bool firstConnect = false;  // 5 хвилин після перезавантаження для одноразової спроби отримання часу з NTP сервера
bool parseStarted = false;  // забороняєм парсити з блютузу;        
bool flagGreeting;          // дозвіл вітатись 

bool dawnIsWorking;         // вже почався світанок
bool runningFlag = true;    // дозволяєм процедуру  ,,бігучий текст,,;           
bool loadingFlag;           // разршает строке принимается в переменную runningText 

bool once = true;           // синхронізуєм лише один раз у вказаний час
bool onceAlarm;             // один раз відтворюємо трек будильника
bool disconnect = true;     // використовується для відключення конектів із точкою доступа під час конекту з NTP сервером часу  
bool nightMode;             // для переходу у нічний режим
bool flagNightLight = false;// для продовженого терміну світіння нічника
uint8_t nowMinute;          // актуальне значення хвилин
uint8_t nowHour;            // актуальне значення годин
int16_t timeDawn;           // для швидкості наростання яскравості у функції світанок
int16_t brightness = 5;     // змінна для значення яскравості годинника
int16_t znachennya = 1000;  // значення швидкості наростання або затухання яскравості LED  
int16_t photoresistorValue; // змінна для значення освітлення з фоторезистора
int16_t bias;               // рахує вертикальні стовбчики
int16_t celsius = 222 ;
uint16_t localPort = 2390;  // локальный порт для прослушивания пакетов UDP
uint32_t timesummerTime;
uint32_t timeBrightnessCheck;
uint32_t timeConectVebServer;
uint32_t timeBrightnessDawn;
uint32_t runningFireTime ;
uint32_t ntpTime;
bool tempFlag = false;
bool dateFlag = false;
bool dot = false;
bool cantor = false;        //в которой хранилось бы состояние счётчика . 
uint8_t arrays = 84;
CRGB leds[NUM_LEDS];        // Define LEDs strip
IPAddress timeServerIP; 
WiFiUDP udp;
ESP8266WebServer server(80);
byte digits [12][32] = {          //двовимірний масив для формування цифр верхнього написання
{0,1,1,1,1,1,1,0,
1,0,0,0,0,0,0,1,
1,0,0,0,0,0,0,1,
0,1,1,1,1,1,1,0}, // Формуєте цифру 0
{0,0,1,0,0,0,0,0,
1,0,0,0,0,0,1,0,
1,1,1,1,1,1,1,1,
1,0,0,0,0,0,0,0}, // Формуєте цифру 1
{0,1,0,0,0,0,1,1,
1,0,1,0,0,0,0,1,
1,0,0,0,1,0,0,1,
1,0,0,0,1,1,1,0},// Формуєте цифру 2
{0,1,0,0,0,0,1,0,
1,0,0,0,0,0,0,1,
1,0,0,1,0,0,0,1,
0,1,1,1,0,1,1,0}, // Формуєте цифру 3
{0,0,1,1,0,0,0,0,
0,0,0,0,1,0,1,0,
1,0,0,1,0,0,0,0,
1,1,1,1,1,1,1,1}, // Формуєте цифру 4
{1,1,1,1,1,0,0,1,
1,0,0,0,1,0,0,1,
1,0,0,1,0,0,0,1,
0,1,1,1,0,0,0,1}, // Формуєте цифру 5
{0,1,1,1,1,1,1,0,
1,0,0,0,1,0,0,1,
1,0,0,1,0,0,0,1,
0,1,1,1,0,0,1,0}, // Формуєте цифру 6
{1,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,1,
1,0,0,1,1,1,1,1,
0,0,0,1,0,1,1,1}, // Формуєте цифру 7
{0,1,1,0,1,1,1,0,
1,0,0,0,1,0,0,1,
1,0,0,1,0,0,0,1,
0,1,1,1,0,1,1,0}, // Формуєте цифру 8
{0,1,1,0,0,0,1,0,
1,0,0,0,1,0,0,1,
1,0,0,1,0,0,0,1,
0,1,1,1,1,1,1,0}, // Формуєте цифру 9
{0,0,0,0,1,0,0,0,
0,1,1,1,1,1,0,0,
0,0,0,0,1,0,0,0,
0,0,0,1,0,0,0,0}, // Формуєте знак плюс
{0,1,1,1,1,1,1,0,
1,0,0,0,0,0,0,1,
1,0,0,0,0,0,0,1,
0,1,0,0,0,0,1,0}  // Формуєте букву С
};

byte digitsPeir [12][32] = { //двовимірний масив для формування цифр нижнього написання
{0,1,1,1,1,1,1,0,
1,0,0,0,0,0,0,1,
1,0,0,0,0,0,0,1,
0,1,1,1,1,1,1,0}, // Формуєте цифру 0
{0,0,0,0,0,1,0,0,
0,1,0,0,0,0,0,1,
1,1,1,1,1,1,1,1,
0,0,0,0,0,0,0,1}, // Формуєте цифру 1
{1,1,0,0,0,0,1,0,
1,0,0,0,0,1,0,1,
1,0,0,1,0,0,0,1,
0,1,1,1,0,0,0,1},// Формуєте цифру 2
{0,1,0,0,0,0,1,0,
1,0,0,0,0,0,0,1,
1,0,0,0,1,0,0,1,
0,1,1,0,1,1,1,0}, // Формуєте цифру 3
{0,0,0,0,1,1,0,0,
0,1,0,1,0,0,0,0,
0,0,0,0,1,0,0,1,
1,1,1,1,1,1,1,1}, // Формуєте цифру 4
{1,0,0,1,1,1,1,1,
1,0,0,1,0,0,0,1,
1,0,0,0,1,0,0,1,
1,0,0,0,1,1,1,0}, // Формуєте цифру 5
{0,1,1,1,1,1,1,0,
1,0,0,1,0,0,0,1,
1,0,0,0,1,0,0,1,
0,1,0,0,1,1,1,0}, // Формуєте цифру 6
{0,0,0,0,0,0,0,1,
1,0,0,0,1,0,0,0,
1,1,1,1,1,0,0,1,
1,1,1,0,1,0,0,0}, // Формуєте цифру 7
{0,1,1,1,0,1,1,0,
1,0,0,1,0,0,0,1,
1,0,0,0,1,0,0,1,
0,1,1,0,1,1,1,0}, // Формуєте цифру 8
{0,1,0,0,0,1,1,0,
1,0,0,1,0,0,0,1,
1,0,0,0,1,0,0,1,
0,1,1,1,1,1,1,0}, // Формуєте цифру 9
{0,0,0,0,0,1,1,0,
1,0,0,1,0,0,0,0,
0,0,0,0,1,0,0,1,
0,1,1,0,0,0,0,0}, // Формуєте знак градусів
{0,1,1,1,1,1,1,0,
1,0,0,0,0,0,0,1,
1,0,0,0,0,0,0,1,
0,1,0,0,0,0,1,0}  // Формуєте букву С
};

long ledColor = CRGB::MediumVioletRed;  // завжди стартуватиме таким коліром ,можна замінити іншим
CRGB dawnColor = CHSV(0, 0, 0);         // для поступової зміни червоного фону на білий у функції ,,світанокк,, 

long ColorTable[24] = {
CRGB::Aqua, 
CRGB::Amethyst, 
CRGB::Cyan,
CRGB::Chartreuse,
CRGB::DarkOrange,
CRGB::DarkMagenta,
CRGB::DeepPink,
CRGB::Gold,
CRGB::Goldenrod,
CRGB::Green,
CRGB::GreenYellow,
CRGB::Fuchsia,
CRGB::Khaki,
CRGB::Lime,
CRGB::LightCoral,
CRGB::MediumSpringGreen,
CRGB::MediumVioletRed,
CRGB::OrangeRed,
CRGB::Orchid,
CRGB::PeachPuff,
CRGB::Red,
CRGB::Salmon,
CRGB::Tomato,
CRGB::Yellow
};

uint8_t PlayTableGreetings[15] = {86,87,88,89,90,91,92,93,94,95,96,97,98,99,100};  //масив треків привітань

int8_t GetEEPROM (uint8_t address, int8_t min, int8_t max, int8_t defaultVal, int8_t subtractor) {
  byte readEEPROM = i2c_eeprom_read_byte( EEPROM_I2C_ADDRESS,address);
 if (((readEEPROM - subtractor) >= min) && ((readEEPROM - subtractor) <= max)) {return readEEPROM - subtractor;}  
 else {return defaultVal;} 
 }
 
byte decToBcd(byte val) {               //конвертуєм у двійково-десятичний формат, для запису у модуль часу 
 return ((val / 10 * 16) + (val % 10)); // наприклад val=59(хвилин), тоді 59/10*16 = 94,4 +(остача ділення на 10)9 = 103,4
} //ціле число 103(у десятковій системі числення) або B1100111 (у двійковій системі) або 0x67 (у 16тичній)

// дані по байтово записуємо у зовнішню EEPROM
void i2c_eeprom_write_byte( int deviceaddress, unsigned int eeaddress, byte data ) {
 Wire.beginTransmission(deviceaddress); // по шині i2c з'єднуємось з девайсом за адресою вказаною в параметрах (аргументах)  
 Wire.write((int)(eeaddress >> 8)); // MSB (старший бит) перший у черзі на передачу в девайс
 Wire.write((int)(eeaddress & 0xFF)); // LSB (младший бит) другий у черзі на передачу в девайс
 Wire.write(data); // ставим у чергу для подальшої передачі в девайс
 Wire.endTransmission(); // передає усе що було в черзі, після завершає передачу даних до девайсу по шині i2c
}

// читаєм по байтово дані із зовнішнього EEPROMу 
byte i2c_eeprom_read_byte(int deviceaddress, unsigned int eeaddress) { // адреса i2c, номер комірки EEPROM (макс.можливе 65535)
 byte rdata = 0xFF; // якщо помилково буде вказана не існуюча алреса комірки EEPROM , тоді повернемо хочаб якесь значення (255)
 Wire.beginTransmission(deviceaddress); // по шині i2c з'єднуємось з девайсом за адресою вказаною в параметрах (аргументах)
 Wire.write((int)(eeaddress >> 8)); // розбиваєм 16бітний int на 8бітні байти (наприклад 1111111100000000 першим у черзі 11111111
 Wire.write((int)(eeaddress & 0xFF)); // потім у ставим у чергу 00000000 (так у EEPROM вибирається потрібна комірка)
 Wire.endTransmission();   // передає усе що було в черзі, після завершає передачу даних до девайсу по шині i2c
 Wire.requestFrom(deviceaddress,1); // отримуєм один байт даних з девайсу
 if (Wire.available()) { rdata = Wire.read(); } // якщо знайдена комірка повернула якесь значення - читаємо і присвоюєм rdata
 return rdata; // повертаєм значення яке у змінній rdata
}

void loop() {
 bluetoothRoutine();
 if (!runningFlag)  {
  if (millis()-runningFireTime >= 100) { 
    runningFireTime = millis();
    ShowDisplay(); // показуємо котра година 
    runningFire();  
    if (disconnect) {server.handleClient();}
  }
  if ((millis()-timesummerTime >= 30000)&&(disconnect)) {
   timesummerTime = millis();
   DaylightSavingTime();
   if (!firstConnect) {
    ConnectWifi();
    connectCont ++ ;
    if (connectCont > 10) {
     firstConnect = true; 
     if (WiFi.status() == WL_CONNECTED) {
      if (GetNTP() ) {CorectTime();} // якщо відбувся звязок із сервером часу викликаєм функцію корекції часу 
     }
    }
   }
  }
  if ((dawnIsWorking)&&(millis()-timeBrightnessDawn >= timeDawn)) {  // якщо активний режим світанку
   timeBrightnessDawn = millis();
   BrightnessDawnFonction();
  }
 }
 if (millis()-timeBrightnessCheck >= znachennya) {   // підлаштовуєм яскравість матриці з вирахованою періодичністю 
  timeBrightnessCheck = millis();
  BrightnessCheck();
 }
}
